# Getting Started

This folder contains scripts to import the RDF endpoint schemata retrieval results produced by [OBIS-SchemaExtractor](https://github.com/LUMII-Syslab/OBIS-SchemaExtractor).

## Steps before the first import

- Set up your DSS according the instructions [here](../db-templates/). Note: DSS is configured automatically, if you use [ViziQuer Tools](https://github.com/LUMII-Syslab/viziquer-tools).

- Obtain a JSON file containing the shape info extracted from the endpoint (see [OBIS-SchemaExtractor](https://github.com/LUMII-Syslab/OBIS-SchemaExtractor), use version 2).

- Choose the name (alias) to be used for the endpoint schema inside the DSS (it must be unique).
  
## Requirements for the import script

- Ensure that `node.js` is installed in version ≥ 16,
- Obtain the database connection information for the DSS database,
- To install the packages required by the import script, run from the command line:

```bash
npm install
```

## Import of the endpoint data

### Automatic and manual modes for the import script

The import script can be used in two modes:

- automatic mode, where the script handles both the database configuration and the import from the JSON file, and
- manual mode, where the script will handle only the import from JSON, and the user is responsible for providing a recipient DB schema.

### The import configuration file 

In both modes, the import options have to be provided via an `env` file.

Create an environment file (copy `sample.env` to `.env`) and configure at least the following variables inside the `.env` file:

  - `INPUT_FILE` – name of the JSON file with the extracted information (see previous section).
  - `DB_URL` – connection string to the Data Shape Server PostgreSQL database,
  - `DB_SCHEMA` – name of the db schema (e.g., `nobel_prizes`) where the data schema information should be imported into

The following variables can be defined, as well:

  - `SCHEMA_DISPLAY_NAME` – schema name for the UI (appears in a dropdown list of available schemas), defaults to `DB_SCHEMA`
  - `SPARQL_URL` – URL for the SPARQL requests to the endpoint (used to execute the queries against; a default version is in the schema)
  - `NAMED_GRAPH` – named graph (optional, use if necessary together with `SPARQL_URL`)
  - `PUBLIC_URL` – public web site for the endpoint (informative, optional)
  - 
  - `CALCULATE_DISPLAY_NAMES` – set to "true" to generate nicer display names calculated from class and property annotations (if available in the schema), replacing the technical names like `Q123` (optional)
  - `ANNOT_LANG_PRIORITIES` – list of language codes specifying the language lookup order for generating display names, e.g., `"de,fr,en"`; defaults to `"en"`
  -
  - `OVERRIDE_DB_SCHEMA` – should the importer replace existing db schema (if exists) (optional, defaults to `false`)
  - `SCHEMA_TAGS` – list of comma separated tags to be added to the schema entry in the schema registry, e.g., `"sample,demo"`. Used for schema list structuring (in case of many schemas). Can be left empty.
  - 
  - `REGISTRY_SCHEMA` – name of the DB schema which stores the schemata registry (optional, defaults to `public`)
  
By default the import script will look for the environment file named `.env`. 

It is also possible to use a named `env` file (e.g., `myendpoint.env`), providing its name as the environment variable `ENV_NAME` (e.g., `ENV_NAME=myendpoint npm run auto`).

### Starting the import in automatic mode

To start the import in automatic mode, enter the following command:

```bash
npm run auto
```

### Importing in the manual mode

Before importing in the manual mode, ensure that the recipient schema contains a clone of the schema `empty`. 

For example, assuming that the name of your DSS database is `dss`, and that the name for your schema is `myendpoint`, issue the following commands:

```bash
psql dss < empty_template.pgsql
psql -c "alter schema empty rename to myendpoint" dss
```

When the recipient schema is created, you can run the import script 

```bash
npm run manual
```


## Meta-parameters for environment tuning

The schema import shall set the basic options for meta-parameters in the schema `public`, tables `endpoints` and `schemata` (the `display_name` field in `schemata` table allows to locate the information related to the performed import).

To repeat import of a schema with the same display name, change the value of the already existing display name, or delete previous row of `schemata`, as well as the matching rows in table `endpoints`.

## Namespace table prepopulation and tuning

If desired, the namespaces table `ns` can also be prepopulated before the import (there is a default pre-population done by the empty schema creation script).

For any prefixes encountered in input JSON, an existing `ns` entry will be used, if possible.

For missing `ns` entries, the prefix.cc API will be queried to get the short form of the prefix.

Still unknown prefixes will get autogenerated short forms like `auto_42`.

The namespaces table can be edited manually after the import. Change the prefixes to the ones you would like to see in the user interface. 

Setting a default namespace would simplify its entity appearance. 

Setting priorities to namespaces will order the entities in code completion lists. 

## Generate human readable display names for classes and properties

By default, class and property local names are used also as their display names. If all or part of these local names are technical, like `Q123`, and these classes or properties have annotations, there is an option to build display names from these annotations.

You can initiate the display name generation as part of the schema import, including

```bash
CALCULATE_DISPLAY_NAMES=true
```

in the `.env` file specifying the import parameters.

Or, if you wish to (re)generate display names for an already imported schema, you can start the name generation separately, with the commands

```bash
cd import-generic
node scripts/display-name-calculator.js
```

The `.env` file has the same format as above.


If the display names already have been generated, you can reset them via SQL executing the following commands:

```sql
update YOUR_SCHEMA_NAME.classes set display_name = local_name;
update YOUR_SCHEMA_NAME.properties set display_name = local_name;
```

After that, you can repeat the display name generation as shown above.

## Acknowledgements

Supported in part by Latvian Science Council project lzp-2021/1-0389 "Visual Queries in Distributed Knowledge Graphs" (since 2022).
